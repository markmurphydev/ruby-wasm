The long week 1.

- [[Install, run, document Hoot Scheme compiler]]
	4pt
	- [x] Clone Hoot 0.1.0 release 
	- [x] Find Guile `main` branch commit as of Hoot 0.1.0 release
	- [x] Clone build, and install correct Guile commit
		- Actually Hoot says it needs `main` Guile, but I think everything it depended on exists in the packaged version.
		- Also I am apparently incapable of managing manually-installed software.
			- I can't for the life of me make Guile install or find the dylibs it built
	- [x] Build Hoot
	- [ ] Compile some simple Scheme programs
	- [ ] Document enough Guile usage info to load and run the Hoot modules
	- [ ] Write up useful facilities
		- [ ] We can certainly output `.wat` files, right?
		- [x] Could I temporarily punt `.wat <-> .wasm` conversion to the Hoot toolchain?
			- Don't need to. Use `wasm-tools`
	Actually, this is a nightmare to install. Putting this on ice.

- [[Lexer end-to-end test infrastructure]]
	4pt
	- [ ] Document workflow for producing lexer e2e tests
	- [x] Write an executable program for the lexer (later the compiler)
	- [x] Make program check for "output lexer information" flag
	- [ ] Format lexemes as Prism does

- [[Walking skeleton ー end-to-end .wasm generation]]
	4pt
	- [ ] Write a few AST nodes – program, statement, nil, ...
	- [ ] Write types for Wasm data structures (module, function, ...)
	- [ ] Serialize those types to `.wat` 
	- [x] Choose external `.wat -> .wasm` conversion tool
		- `wasm-tools`
	- [ ] Document `.wat -> .wasm` conversion workflow
		- If it can be a Rust lib (`binaryen` or `wasm-tools`), just make a module for it.
	- [ ] Document procedure for running, debugging output files

- [[Browser .wasm runner page]]
	2pt
	- [ ] Research – I'm certain MDN or someone has info.
	- [ ] Write HTML for file picker
	- [ ] Write JS for loading `.wasm` file
	- [ ] Run the start function, print its output to console
	- [ ] Document procedure for running `.wasm` files in browser

- [[Research value representation in dynamic languages]]
	2pt
	- [ ] Find Ruby internal docs for CRuby
	- [ ] Document how it represents values
	- [ ] Find Ruby internal docs for MRuby
	- [ ] Document how it represents values
	- [x] Find Hoot docs for value representation
	- [ ] Document how Hoot represents values in Wasm output
# Completed

- [[Get a Ruby parser to produce reference ASTs]]
	1pt
	- [x] Figure out how to do this in Prism
	- [x] Document doing this in Prism

- [[Install wasm utilities]]
	1pt
	- [x] Document wasm utilities
	- [x] Install utilities
		[[Utilities]]

- [[Document Ruby parsing situation]]
	3pt
	- [x] Research Ruby parsing situation
	- [x] Document parsing situtation, various parsers.
	- [x] Determine the correct parser to reference
		- It's Prism. Default in CRuby, used extensively in tooling.
	- [x] Install Prism

- [[Write the easy part of lexer]]
	8pt
	- [x] Get a list of token-types from the [[Ruby Implementation Parsing#Prism Parser]] grammar or elsewhere
	- [x] Review the Crafting Interpreters lexer strategy
	- [x] Keywords
	- [x] Non-keyword identifiers
	- [x] Constants (Can differentiate from identifiers textually)
	- [x] I think class and instance variables might be tokenizable too. Do them if so.
	- [x] Punctuation
	- [x] Character literals
	- [x] ints
	- [x] floats
	- [x] single/double-quote strings (none of that Heredoc business yet)
		- Revision: Double-quoted strings are hard. Skip for now.
	- [x] Inline comments
	REMOVED:
	- [ ] Unit testing