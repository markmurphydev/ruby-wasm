[[Is wasm becoming garbage?]]
- Downloaded from Youtube auto-generated subtitles, cut and edited by Claude AI.

Okay, so for the rest of my talk I just want to run through a couple of a few examples of common things you implement for managed languages and how they would map to this thing and basically the whole idea is that none of that should be surprising. You basically should do the same that you do in a native code compiler, right? So this might just all be totally boring because I'm just showing you things you already know but you just use them in WebAssembly as well. Before I do that, a very quick recap of some of the things about WebAssembly for those who haven't seen it perhaps.

So WebAssembly is a stack machine, so you have instructions like this. So this would be an addition of two constants, right? And that could be reduced to this one constant, and that's actually how the execution of WebAssembly is specified formally by a reduction semantics. So it literally says something like this as a reduction rule.

Instructions are also typed, so that's what we get validation out. And since these are stack instructions, they all have a sort of function type - the left hand side saying what you pop off the stack and the right hand side saying what you push back to the stack, like you see with the add instruction. It's like the obvious thing.

And the main reason I'm showing you this is so this is the WebAssembly text format, and one feature it has on top of this stack-like language is what we call the folded syntax. So you can actually write this sequence of instructions this way as well, so as if they were in expressions, right? This is really just syntactic sugar, has no semantic meaning whatsoever. It's really desugared into the same thing, but it makes code much more readable because you see how things are grouped together. And that's why I'm showing that here because I'm going to use that in some of my examples to make them a bit more readable. So when you see this, basically you can completely forget that there's a stack machine underneath. Just read it as a very verbose expression syntax, right?

There's also structured control flow. I think I'm going to skip over that because it's not actually relevant to anything in my talk. So let's jump to examples.

The most obvious one you want to see probably is how to compile classes, right? That's the ubiquitous thing in the object-oriented world. Let's take a simple example in some pseudo-code language. I'm not picking any specific language here, but I guess this should is something you can do in a language like Java and others. So it's just a class with one instance variable, two methods, and let's say there's another class which is a subclass of that which adds another method and another instance variable.

And as most of you I'm sure know, is the standard way of compiling this is so the instance of C would be represented as a block of memory which has all the instance fields - so a in this example - and but the first thing is a method table pointer or vtable as the C++ folks call it. So this vtable points to another heap or memory allocated data structure which is just a vector of all the methods of that class, and this one is shared between all the instances of that class. And similarly for D, you just add the additional fields, but the structure is the same.

So this is the kind of thing we actually need to lay out or emulate when we compile to WebAssembly as well, right? We have to implement that ourselves. At the same time, so D is supposed to be a subtype of C, so ideally we want to define types in WebAssembly that preserve the subtyping relation so that this - the layout for D - so a reference to D is actually a subtype for a reference to C. And that implies also that we have to have the corresponding subtyping between the method tables so that the width subtyping works out.

Okay, let's see how we do that. So first we want to lower the class C into type definitions. So we introduce one for instance, and that should just match exactly like this box I show you in the bottom. Unfortunately my pointer isn't working here so I can't really point at things, but you see what I mean I hope. So it has this one instance field which is the i64, and the first part - the first field - is the method table pointer, and that again is just a struct of two references containing function pointers, and which we also have to define as types. By the way, I'm using somewhat more pseudo syntax here for the type definitions that is not really WebAssembly syntax, but that might be a bit more readable. I hope you appreciate that.

So the yeah, the function pointers we also have to declare as types, and you do it as you usually do when you compile these things. You have functions that take the appropriate arguments, but as a first argument they always take a pointer to the instance itself, right? So this should all be very unsurprising.

And similarly we lower class D. Now the structs correspond to the boxes on the right, and they have these additional fields there. Otherwise they are the same, and we have this one extra function, and that takes as a parameter a reference to a D because it's a method introduced in class D.

So so far everything is great. This actually works out with respect to WebAssembly subtyping. The type D is a subtype of C, and so are the vtable types. All great.

Well, oh yeah, one more thing just for completeness. Let me also show how some of the code would translate. So say the function - the method F there - we lower that to a WebAssembly function on the bottom that takes the parameters as defined by the type there. So an instance pointer - the this pointer - and the actual parameter. And then we just do an addition on that, and the struct.get there extracts the instance field from the instance, right? So this is just the struct.get 1 extracts the a field from type C.

And for completeness, let's also look at an elimination side. So say we have some variable d which is an object of type D, and we invoke the inherited method F on that. So that lowers into something like a call_ref. So call_ref is an instruction for calling a function reference - so an indirect call. And what reference are we calling? Well, the thing we have to call is the method F. So we have to - the only thing we have is a d which is the instance. So we first have to get to the method table. That would be the struct.get 0 - the first struct.get 0. And then we have the method table, and from that we have to extract the pointer to F itself, which is the second struct.get. So this gives us the pointer to F. We call that, and in addition we have to pass the appropriate arguments. The first one being the this argument, which is D itself, and the constant, right? So again, I hope this is not surprising at all. I'm just showing you the obvious.

Okay, so far so good. Now let's slightly modify the examples such that D overrides F. This is where it gets a bit more interesting. So lowering of C doesn't change. For D, we now lower uh... except that here we now have in the method table for D we have d.f. But one thing you see here is I wrote C there. Why did I do that?

Well, and that is exactly where like we run into one of the limitations of the WebAssembly type system. And this is obviously of course a well-known problem that this argument is like covariant in these object encodings, but that doesn't work with contravariant sound function subtyping, right? So the WebAssembly type system isn't strong enough to know that the contravariant subtyping would be sound here. So we can't use it. We actually have to use C there as well. So the type for d.f - this has to be the same as for c.f. Otherwise the subtyping wouldn't work out on the WebAssembly level. If we do it that way, then it works out, but of course that also has some implications for how we actually implement a method override.

So just as a reminder, this is how c.f looked - same as on the slide before. But for d.f, the problem now is that we get as a parameter a reference to C, not D, right? So the first thing we have to do is we have to downcast it to an actual D. And the producer - so the generating compiler - of course knows by construction that this will always work out fine unless the compiler has a bug. But the engine - the WebAssembly engine - can't know that, right? It can't prove that. So that's why you have to do a cast there. Yeah, and then you do the addition as before.

Okay, so this is one point where we run into limitations, and one thing I - we maybe can lift to some extent in the future. But in general there will always be limitations like that. You will always have to use cast somewhere.

So related examples is closures. I actually might want to skip over that because it's very similar. So this would be in a functional language where you implement closures. But if you know that closures are really - you can view closures as a degenerate case of a class that has just a single method, right? Which means that you can flatten the V table into the object itself. That's how they are compiled. That's also how Java for example models closures with inner classes. So the point being that you run into exactly the same problem here when - so you define specific closure type that is a subtype of the general closure type for a given function, and you have to do at the call side the same kind of downcast of the closure environment to the one to the function's own environment type. And the same like type system extension that would fix the thing for classes would also fix this thing for closures. So that's something I eventually want to get here.

Another example: what do you do with generics? Well, we don't have generics in the language, so you do the obvious thing. You do erasure, right? So as a stupid simple example, let's say we have a pair - generic pair of two-dimensional vector if you want over T - and we define two generic functions to just do the projections. Boring example but fits on a slide.

So because you can't do generics, well, you have to use the top type. The top type in WebAssembly is called any. So this is an anyref. I just declare the pair as a struct of two anyrefs, and then the functions they just work out because they also just return anyrefs. There's nothing I have to do here. But I have to do something when I want to invoke these, right?

So let's say I want to interpret this as a two-dimensional vector and want to compute its absolute value. So I have something like this function which takes the square root of - oh, there's some invocations of square missing there I just noticed. Right, so there should be - both components should be squared of course for this formula to be correct. But despite my bad math here, this would be lowered somehow into WebAssembly, and my animation was somewhat broken as well.

So first of all, one thing we have to do is we have to define a type for boxed floats, right? Because we need something we can pass to this pair function that has to be a reference. So we have to box up floats. So that would just be a singular singleton structure that contains an f64. And then the function apps itself - well, what does it do? What you would expect. It has the two calls, and because they return anyref, it now has to downcast to the float type - the boxed float type - before it can access them. So that is another place where we have to insert cast. But this is really like how Java also does it officially, right?

Okay, so let's switch again to the functional world a little bit and talk about algebraic data types or variant types. As an example for that, let's assume we in a nice functional language and want to write an interpreter for WebAssembly itself. So we need to define some data type that represents the WebAssembly instruction set, right? So just showing a bunch here like const and drop instructions and branches and blocks.

So we need to lower this as well, of course. And the idea here is we want to do what functional compilers also do, which is unbox the nullary constructors. You don't want to heap allocate them because you really just want to represent them as an integer. They're really just like an index representing the constructor.

So the type itself we want to represent as type any, which is kind of the union of all ref reference types. And then there are two concrete cases. One is i31, which is the unboxed nullary constructor case. And then the boxed case is going to be a super type of all concrete constructors that are not nullary. So concretely we have one type for each of the constructors that has parameters, which is a struct of the respective thing. But the first element of this struct is an index telling you what case you're in. And if you just have the super type, you can use that to do your dispatch.

So let's look at an example of how you would use this in practice or compile this in practice. So let's say we want to write an evaluator for WebAssembly. So part of that might be a stepping function which takes a stack and a single instruction and returns the modified stack and possibly some kind of list of continuation instructions. And the way to implement that in a functional language is through pattern matching obviously. Ignore all the right hand sides - they don't really matter here. But what matters is that we do this pattern matching on the left, right? So we dispatch on the constructor of the data type.

So how do we lower this? Well, we have a function that takes the respective parameters - so a stack and an instruction reference - and now we have to implement this dispatch. So the first thing we do is we look which case we are in. Is it a nullary constructor or not? So we do a branch on cast with the boxed type. We could also do it the other way around, but here I use the boxed type. And this cast - if it succeeds, this instruction would branch to some label L which would be lower down in the function. I'm not showing that yet. And if the cast fails, it will just fall through and the next instruction is executed. So in that case we actually know - again the producer knows by construction - it has to be an i31 then. So it can just unconditionally cast that down to i31 the instruction, and then it can get the index out of that. So that would tell us what constructor we have. And then we do a br_table, which is dispatching on that number and jumping to some labels - one for each of the instructions we need to implement - and they would be somewhere further down in this function.

And the other case is if we took the branch to L. So if we are in the non-nullary case, then we somehow get here. And there we can - one thing it's bit difficult to see here, but one thing that the branch instruction does is that the label actually receives the reference on the stack as well, but with a refined type. So when we arrive at L, we have on the top of our operand stack actually a reference not to the instruction type but to the instruction_boxed type. So we already know it's one of these things. So we can just get the index field there. And here's where the kind of function expression notation breaks down a little bit because the operand to the struct.get is already on the stack implicitly. We can't really write it here, but just assume there it's coming from the jump. So again, we just do a dispatch table jump on that index, and then the rest of the function just implements all these cases we have to jump to, right? That's all you do.

Okay, and my final example is something called uniform representation. So that appears when you have a language that is highly polymorphic. So functional languages would be an obvious example where you have type inference and many types you infer are polymorphic actually, and you want it that way. The extreme example of that is if you want is actually untyped languages or dynamic languages where everything is polymorphic basically, right?

And the thing is with these languages, so people who have not seen implementations of functional languages often assume yeah, when you have polymorphism with generics, right, you can always just statically type specialize them. But that doesn't work in these languages because their type system is actually much too powerful for that. So they have things like first class polymorphism, polymorphic recursion, other things that make it impossible to statically know all the instantiations that occur during execution of a program. The same - this is related to what you also have in all languages if you have virtual methods as they would call them in C++ - so generic methods, right? In C++ they are not allowed, and the reason is exactly that it doesn't work with static type specialization.

So for functional languages is like not an option at all because polymorphism is everywhere and typically first class and other features. So you can't do that. So but also polymorphism is everywhere, so you're crossing the boundaries between monomorphic and polymorphic code all the time, and you don't want to do boxing/unboxing translation uh conversions all the time either because that would be very costly as well.

So what typically these implementations do then is that they represent all values uniformly. So you don't have to convert them. You all represent them as references - in WebAssembly speak under the type any, right? And then only when you need to access a value concretely, you have some elimination form, then you can like cast it down or extract the correct type.

So I implemented a whole like ML compiler on top of that as kind of a proof of concept thing, and I'm going to show you what kind of representation that used. But this so - this roughly is what also the OCaml compilers would be using or the Scheme compiler is using something very similar.

So for example, the ML type - has a type bool which in this uniform representation you just represent as a i31 reference. There might be places where you can unbox it locally when you use an i8 or something, but in most - in the general place - it will always represent as an i31. And similarly with characters, which are a bit larger than a bool but still fit in an i31, so you can use that for that.

Actual integer types - well, that might depend on what value range you want to have. So you could either use i31 as well, or you have to box it up into a struct, maybe even a struct with i64 in it. You can also have a mixed representation, right, which would be for example what Scheme would be doing with its numeric tower where you allow both these things and then convert as necessary.

Floats you have to box up because they can't be stuffed into a reference. And then strings - well, just an array, like say in UTF-8 encoded array of bytes.

Tuples - you already saw that with a pair example. That would be a of anyrefs now, right? Because the thing being with polymorphism, you can abstract the component types after the fact. So and you never know beforehand when you have a tuple what context you're passing it into. So you can't assume beforehand that it will not be polymorphic some way. So you also have to use a uniform representation there.

I already showed you how - well I skipped over that but I sketched how closures work. And data types I showed you on the last slide. ML also has a very advanced module system which is higher order and everything. So that also would lower to structs and functions. But the point being here that yeah, i31 is relatively important here so that you can have all these unboxed representations.

Okay, those were all the examples I wanted to show. Just like as my last slide, essentially a number of limitations. So the one you already saw of course is that we have to do cast a number of times. And some preliminary numbers reported by us by the compiler - just was that this - they saw like two to 4% overhead in that. So V8 has an option to turn off the runtime checks for cast, you can so you can measure that quite easily what the cost of the actual cast is.

I also said that there is no automatic interop between languages, so you need to define your own APIs. And then maybe more interesting thing is that well, this is of course a feature that has to cover certain use cases, but there will always be use cases that can't cover. So there are languages that have very particular needs for their GC. So one example would be Go, which made this interesting design choice to allow interior pointers into objects, which we can't directly represent because we don't want to burden every WebAssembly engine with implementing this mechanism because it's quite horrible.

Then there are languages like Prolog or Haskell which have things like logic variables or lazy thunks which once they get bound could can produce chains of indirections that usually their garbage collectors want to shorten and eliminate. Maybe there's a way to get an abstraction for that, but right now they wouldn't be able to use this optimization.

And the biggest one is where we still kind of like have no good ideas what to do about weak reference finalization, right? There are so many different semantics for that out there. Every language has its own. They all are incompatible with each other. Some even have three different versions of it. So what is the right abstraction for this kind of thing that doesn't mean that we're adding all of them? And also what does maintain all the good properties we want to have.

And a final thing I need to mention is one of the drawbacks of having this typed assembly language is of course that a compiler targeting this language has to produce this type information, and that could be problematic if you have a legacy compiler which throws away its type information too early in some of the representations. Then it might not have enough information in the back end to generate this, right? So if you have a compiler and you want to write a new back end for that targets the WASM GC extension, then this might be a problem for you, and you might have to do some extra work.

Okay, that's basically what I had. Yeah, the main takeaway I want to bring across that this is - although it's GC, it's low-level GC, and you still have to do everything you have to do on native more or less minus implementing the actual GC. That's the only thing the this extension gives you. And this is like a version 1.0 feature, so it definitely is much room for improvement, and we will based on feedback on what we get from clients - we I'm sure we will add more stuff to that over time.

Okay, that's all I had. Just a reminder, and I'm happy to take questions. We have for a couple.

**Question 1:** So I imagine that there will be some runtimes that choose not to implement the GC proposal for one reason or another. One I guess is that permitted? And even if it's not permitted, they're going to do it anyway. So what effect do we think that would have on the ecosystem? Would it bifurcate the ecosystem into WASM modules that run on those runtimes and modules that do not?

**Andreas:** Yeah, that's an excellent question, and there's an ongoing discussion about that - introducing some notion of profiles into WebAssembly. I think this is absolutely essential. GC is not the only feature that some ecosystems might not be able to implement. Like threads is another. Continuations is another. SIMD is something that is super large, and like an embedded platform might not care about or not get any benefit out. So what I have proposed is that we introduce like a general framework for defining profiles which define very precisely certain language subsets, and then these environments can pick whatever subset they can handle, right? And GC should definitely be like a profile. GC-less determinism is another important one, by the way, for blockchains. They absolutely need a deterministic semantics, so there's going to be a profile for that.

**Question 2:** You didn't actually talk about GC itself. Right, I'm curious - one thing is, does it have to use the static type information? What the sort of static type information does it need, like metadata associated with variables and so on to trace the references?

**Andreas:** So of course the specification doesn't say anything about the GC, right? You just like - it just works. But there are some implicit assumptions of course about the performance of a GC, like since you can do rather fine grain allocations, the GC should be able to handle frequent and fine grain allocations. Other than that, it's completely up to the engine and probably the environment it's running in, right? Which is the best implementation technique for that - we don't prescribe anything in particular. That's left for yeah, quality of implementation issue and depending on ecosystem, hardware, whatever, right? Other than it has to be typed. Yeah, but that is validation, right? Like that is not the GC itself, isn't... I mean operationally this whole feature is actually quite straightforward. There isn't anything fancy happening here. It's all that we have to validate it so that we know that nothing bad can happen when you access GC objects.

**Follow-up:** I guess I'm missing something then because I mean I'm familiar with the .NET GC and it actually has to look at type information so it knows object layout and so on, but in the objects...

**Andreas:** Yeah, you need to have some minimal type information of course. So you need to be able to distinguish these four kind of reference I showed you, right? But that is much, much simpler type information than the actual WebAssembly type system, right?

**Follow-up:** You... okay, thank you very much.

**Andreas:** Let's switch to the next speaker.

再試行